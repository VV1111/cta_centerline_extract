#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Artery GUI ‚Äî Qt-compatible skeleton using pyqtgraph (PyQt5/6 or PySide2/6)

Requirements
- pyqtgraph
- nibabel
- numpy

Run
    python ArteryGUI_QtCompat_Skeleton_v1.py

Notes
- Import style is fixed to: `import pyqtgraph as pg` and
  `from pyqtgraph.Qt import QtCore, QtWidgets, QtGui` per your request.
- Left column: toolbar with "Open NIfTI" and basic controls.
- Middle column: three small preview panes (Axial / Coronal / Sagittal) + a single global slice slider.
- Right column: a large detail view that mirrors (and controls) the selected preview.
- Click the üîç icon on a preview to show that plane in the large detail view.
- Panning/zooming in the right (detail) view is mirrored back to the active preview.
- Any future drawing/ROI in the big view should use the same ViewBox transform to map to image coords.

This is a minimal but clean, extensible scaffold.
"""

import sys
import os
import numpy as np
import nibabel as nib
import pyqtgraph as pg
from pyqtgraph.Qt import QtCore, QtWidgets, QtGui
from pyqtgraph.Qt.QtGui import QKeySequence, QShortcut
import pyqtgraph.opengl as gl


# ---------- Utility: centralize plane names ----------
PLANES = ["Axial", "Coronal", "Sagittal"]


class VolumeData(QtCore.QObject):
    """Hold a 3D numpy array and expose plane-wise slice counts & getters."""
    dataChanged = QtCore.Signal()
    paramsChanged = QtCore.Signal() 

    def __init__(self):
        super().__init__()
 
        self.window_level = None   # None Ë°®Á§∫Êú™ÂêØÁî® WL
        self.window_width = None   # None Ë°®Á§∫Êú™ÂêØÁî® WW
        self._gmin = None          # ÂÖ®Â±ÄÊúÄÂ∞èÂÄºÔºàÂä†ËΩΩÊó∂ËÆ°ÁÆóÔºâ
        self._gmax = None          # ÂÖ®Â±ÄÊúÄÂ§ßÂÄºÔºàÂä†ËΩΩÊó∂ËÆ°ÁÆóÔºâ

        self._vol = None  # numpy array, shape (Z, Y, X) or any 3D
        self._affine = None  # NIfTI affine (unused now, reserved)
        # Current slice indices for each plane
        self.slices = {"Axial": 0, "Coronal": 0, "Sagittal": 0}
        
        # mask Áõ∏ÂÖ≥
        self._mask = None          # Êï¥ÂûãÊ†áÁ≠æ‰ΩìÁ¥†ÔºåÂΩ¢Áä∂‰∏é _vol ‰∏ÄËá¥
        self.mask_alpha = 0.6      # 0~1 ‰πãÈó¥
        # self.display_mode = "overlay"   # "overlay" | "image_only" | "mask_only"
        self.display_mode = "overlay"   # "overlay" | "image_only" | "mask_only" | "image_masked"

        self._lut_colors = None    # (K, 4) RGBA uint8 È¢úËâ≤Ë°®ÔºàAÈÄöÈÅì‰∏çÁî®ÔºåÊåâÂÉèÁ¥†Â°´Ôºâ
        
    def is_loaded(self):
        return self._vol is not None and self._vol.ndim == 3

    def load_nii(self, path: str):
        img = nib.load(path)
        arr = img.get_fdata(dtype=np.float32)

        self._vol = np.asarray(arr)
        self._affine = img.affine
        # Reset slice indices to center slices
        z, y, x = self.shape_zyx()
        self.slices["Axial"] = z // 2
        self.slices["Coronal"] = y // 2
        self.slices["Sagittal"] = x // 2
        
        flat = self._vol[np.isfinite(self._vol)].ravel()
        if flat.size > 0:
            self._gmin, self._gmax = float(np.min(flat)), float(np.max(flat))
            if self._gmax <= self._gmin:
                self._gmax = self._gmin + 1.0
        else:
            self._gmin, self._gmax = 0.0, 1.0

        self.dataChanged.emit()
        self.paramsChanged.emit()

    def load_mask(self, path: str):
        img = nib.load(path)
        arr = img.get_fdata(dtype=np.float32)
        self._mask = np.asarray(np.rint(arr).astype(np.int32))  # ÂõõËàç‰∫îÂÖ•Âà∞Êï¥Êï∞Ê†áÁ≠æ
        # ÁÆÄÂçï‰øùÊä§ÔºöÂΩ¢Áä∂‰∏ç‰∏ÄËá¥Êó∂Â∞ùËØïÂπøÊí≠Â§±Ë¥•Â∞±Êä•Èîô
        if self._vol is None or self._mask.shape != self._vol.shape:
            raise ValueError(f"Mask shape {self._mask.shape} != image shape {None if self._vol is None else self._vol.shape}")
        # ÊûÑÂª∫È¢úËâ≤Ë°®
        self._build_lut_from_mask()
        self.paramsChanged.emit()   # Ëß¶ÂèëÊ∏≤ÊüìÂà∑Êñ∞

    def _build_lut_from_mask(self):
        if self._mask is None:
            self._lut_colors = None
            return
        labels = np.unique(self._mask)
        max_label = int(labels.max()) if labels.size else 0
        K = max(2, max_label + 1)   # Ëá≥Â∞ëÂåÖÂê´ 0 ÂíåÊúÄÂ§ßÊ†áÁ≠æ
        lut = np.zeros((K, 4), dtype=np.uint8)  # RGBA
        # 0 Âè∑ËÉåÊôØÈÄèÊòéÔºàÈ¢úËâ≤ÈöèÊÑèÔºåËøôÈáåÁΩÆÈõ∂Ôºâ
        lut[0] = (0, 0, 0, 0)
        # ‰∏∫ 1..K-1 ÁîüÊàêÂèØÂàÜËæ®È¢úËâ≤ÔºàHSV ÂùáÂåÄÂèñËâ≤Ôºâ
        for i in range(1, K):
            h = (i * 0.61803398875) % 1.0  # ÈªÑÈáëÊØî‰æãÈÅøÂÖçÁõ∏Ëøë
            s, v = 0.9, 0.95
            r, g, b = self._hsv_to_rgb(h, s, v)
            lut[i] = (int(r*255), int(g*255), int(b*255), 255)
        self._lut_colors = lut


    @staticmethod
    def _hsv_to_rgb(h, s, v):
        import colorsys
        return colorsys.hsv_to_rgb(h, s, v)

    def set_mask_alpha(self, a: float):
        a = float(np.clip(a, 0.0, 1.0))
        if a != self.mask_alpha:
            self.mask_alpha = a
            self.paramsChanged.emit()

    def set_display_mode(self, mode: str):
        mode = mode.lower()
        if mode not in ("overlay", "image_only", "mask_only", "image_masked"):
            mode = "overlay"
        if mode != self.display_mode:
            self.display_mode = mode
            self.paramsChanged.emit()

    def has_mask(self) -> bool:
        return self._mask is not None

    def get_mask_slice(self, plane: str, idx: int) -> np.ndarray | None:
        if not self.has_mask():
            return None
        z, y, x = self._mask.shape
        if plane == "Axial":
            idx = np.clip(idx, 0, z - 1);  return self._mask[idx, :, :]
        if plane == "Coronal":
            idx = np.clip(idx, 0, y - 1);  return self._mask[:, idx, :]
        if plane == "Sagittal":
            idx = np.clip(idx, 0, x - 1);  return self._mask[:, :, idx]
        return None

    def render_mask_rgba_slice(self, plane: str, idx: int) -> np.ndarray | None:
        """Â∞ÜÊ†áÁ≠æÂàáÁâáÔºàintÔºâÊò†Â∞Ñ‰∏∫ RGBAÔºàHxWx4 uint8ÔºâÔºåËÉåÊôØÊ†áÁ≠æ0‚Üíalpha=0„ÄÇ"""
        if not self.has_mask() or self._lut_colors is None:
            return None
        lab = self.get_mask_slice(plane, idx)
        if lab is None:
            return None
        lab = np.asarray(lab, dtype=np.int32)
        lut = self._lut_colors
        K = lut.shape[0]
        lab_clip = np.clip(lab, 0, K-1)
        rgba = lut[lab_clip]                    # (H, W, 4)
        # Â∫îÁî®ÂÖ®Â±ÄÈÄèÊòéÂ∫¶ÔºöÊ†áÁ≠æ>0 Êâç‰ΩøÁî® alpha
        if self.mask_alpha < 1.0:
            alpha = rgba[..., 3].astype(np.float32) * self.mask_alpha
            rgba = rgba.copy()
            rgba[..., 3] = np.clip(alpha, 0, 255).astype(np.uint8)
        return rgba

    def render_image_masked_slice(self, plane: str, idx: int) -> np.ndarray | None:
        """
        ËøîÂõûÂè™‰øùÁïô mask>0 ÈÉ®ÂàÜÁöÑÁÅ∞Â∫¶ÂõæÔºàfloat32, 0~1ÔºâÔºåmask Â§ñËÆæ‰∏∫ 0„ÄÇ
        Ëã•Êú™Âä†ËΩΩ maskÔºåÂàôËøîÂõûÊôÆÈÄöÊ∏≤ÊüìÁªìÊûúÔºàminmax Êàñ WL/WWÔºâ„ÄÇ
        """
        base = self.render_slice(plane, idx)
        if base is None:
            return None
        if not self.has_mask():
            return base
        lab = self.get_mask_slice(plane, idx)
        if lab is None:
            return base
        m = (lab > 0).astype(np.float32)
        # Ê≥®ÊÑèÔºöbase ÊòØÊåâÁÖß (row,col)ÔºõÂêéÁª≠ setImage(img.T) ‰ºöËΩ¨ÁΩÆÔºåÊâÄ‰ª•ËøôÈáå‰∏çËΩ¨ÁΩÆ
        out = base * m
        return np.nan_to_num(out, nan=0.0, posinf=1.0, neginf=0.0).astype(np.float32, copy=False)

    def render_slice(self, plane: str, idx: int) -> np.ndarray:
        img = self.get_slice(plane, idx)
        if img is None:
            return None
        if self.window_level is not None and self.window_width is not None:
            return self._apply_window(img)
        else:
            return self._apply_minmax(img)
        
    def _apply_window(self, img2d: np.ndarray) -> np.ndarray:
        L = float(self.window_level)
        W = float(max(1e-6, self.window_width))
        lo, hi = L - W * 0.5, L + W * 0.5
        out = np.clip((img2d - lo) / (hi - lo), 0.0, 1.0)
        out = np.nan_to_num(out, nan=0.0, posinf=1.0, neginf=0.0).astype(np.float32, copy=False)
        return out


    def _apply_minmax(self, img2d: np.ndarray) -> np.ndarray:
        gmin = self._gmin if self._gmin is not None else float(np.nanmin(img2d))
        gmax = self._gmax if self._gmax is not None else float(np.nanmax(img2d))
        if not np.isfinite(gmin) or not np.isfinite(gmax) or gmax <= gmin:
            gmin, gmax = 0.0, 1.0
        out = np.clip((img2d - gmin) / (gmax - gmin), 0.0, 1.0)
        # ÂèØÈÄâÂÖúÂ∫ï
        out = np.nan_to_num(out, nan=0.0, posinf=1.0, neginf=0.0).astype(np.float32, copy=False)
        return out




    def set_window(self, level: float, width: float):
        # Ëã•ÊÉ≥‚ÄúÊ∏ÖÁ©∫ WL/WW ÂõûÂà∞ MinMax‚ÄùÔºåÂèØ‰ª•‰º† NoneÔºàUI Â±Ç‰∏çÈúÄË¶ÅÁöÑËØùÂèØ‰∏çÂÅöÔºâ
        if level is None or width is None:
            changed = (self.window_level is not None) or (self.window_width is not None)
            self.window_level, self.window_width = None, None
        else:
            level = float(level)
            width = float(max(1e-6, width))
            changed = (self.window_level != level) or (self.window_width != width)
            self.window_level, self.window_width = level, width
        if changed:
            self.paramsChanged.emit()

    def shape_zyx(self):
        if not self.is_loaded():
            return (0, 0, 0)
        # Interpret array as (Z, Y, X)
        z, y, x = self._vol.shape
        return z, y, x

    def max_index(self, plane: str) -> int:
        z, y, x = self.shape_zyx()
        if plane == "Axial":
            return max(0, z - 1)
        if plane == "Coronal":
            return max(0, y - 1)
        if plane == "Sagittal":
            return max(0, x - 1)
        return 0

    def get_slice(self, plane: str, idx: int) -> np.ndarray:
        """Return raw 2D slice (float32) for a given plane+index (no normalization)."""
        if not self.is_loaded():
            return None
        z, y, x = self._vol.shape
        if plane == "Axial":
            idx = np.clip(idx, 0, z - 1)
            return self._vol[idx, :, :]
        if plane == "Coronal":
            idx = np.clip(idx, 0, y - 1)
            return self._vol[:, idx, :]
        if plane == "Sagittal":
            idx = np.clip(idx, 0, x - 1)
            return self._vol[:, :, idx]
        return None


class ImagePreview(QtWidgets.QFrame):
    """A small preview widget with a title bar and a üîç button to promote to the detail view."""
    # zoomRequested = QtCore.Signal(str)  # plane name
    zoomRequested = QtCore.Signal(object) 
    sliceChanged = QtCore.Signal(str, int)
    # update3DRequested = QtCore.Signal()


    def __init__(self, plane: str, volume: VolumeData):
        super().__init__()
        self.setObjectName(f"Preview_{plane}")
        self.plane = plane
        self.volume = volume
        
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)

        # Title bar
        title = QtWidgets.QHBoxLayout()
        self.lbl = QtWidgets.QLabel(f"{plane}")
        self.lbl.setStyleSheet("font-weight: 600;")

        self.hdrSlider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.hdrSlider.setMinimum(0)
        self.hdrSlider.setMaximum(0)
        self.hdrSlider.setSingleStep(1)
        self.hdrSlider.setPageStep(5)
        self.hdrSlider.setFixedHeight(18)
        self.hdrSlider.valueChanged.connect(lambda v: self.set_slice(int(v)))

        self.btnZoom = QtWidgets.QToolButton()
        self.btnZoom.setText("üîç")
        self.btnZoom.setToolTip("Show this plane in the large view")
        # self.btnZoom.clicked.connect(lambda: self.zoomRequested.emit(self.plane))
        self.btnZoom.clicked.connect(lambda: self.zoomRequested.emit(self))
        # title.addWidget(self.lbl)
        # title.addWidget(self.hdrSlider, 1) 
        # title.addWidget(self.btnZoom)

        title.addWidget(self.lbl)

        # ‰∏≠Èó¥ÁöÑÁªÜÈïø slider
        title.addWidget(self.hdrSlider, 1)

        # Êñ∞Â¢ûÔºöUpdate 3D ÊåâÈíÆÔºàÁÇπÂáªÂêéÊâçÊ∏≤Êüì3DÔºâ
        # TODO Ëøô‰∏™Â∫îËØ•ÊòØÂè™ÊúâËøô‰∏™3d È¢ÑËßàÊâçÊúâÂÖ∂‰ªñÊ≤°Êúâ
        # self.btnUpdate3D = QtWidgets.QToolButton()
        # self.btnUpdate3D.setText("Update")
        # self.btnUpdate3D.setToolTip("Regenerate 3D preview with current mode")
        # self.btnUpdate3D.clicked.connect(self.update3DRequested.emit)

        # title.addWidget(self.btnUpdate3D)

        # ÊîæÂ§ßÊåâÈíÆ
        title.addWidget(self.btnZoom)

        # Graphics view
        self.glw = pg.GraphicsLayoutWidget()
        self.view = self.glw.addViewBox(lockAspect=True, enableMenu=False)
        self.view.setMouseEnabled(x=True, y=True)
        self.img_item = pg.ImageItem()
        self.view.addItem(self.img_item)
        self.img_item.setLevels((0.0, 1.0)) 

        self.mask_item = pg.ImageItem()          # È°∂Â±Ç maskÔºàRGBAÔºâ
        self.mask_item.setZValue(10)
        self.view.addItem(self.mask_item)

        # Local slice slider for this preview (hidden; we use global slider primarily)
        self.slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.slider.setMinimum(0)
        self.slider.setMaximum(0)
        self.slider.valueChanged.connect(self._on_local_slider_changed)
        self.slider.setVisible(False)  # keep it hidden to honor the single global slider design

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addLayout(title)
        lay.addWidget(self.glw)
        lay.addWidget(self.slider)

        # React to data changes
        
        self.volume.dataChanged.connect(self.refresh)
        self.volume.paramsChanged.connect(self.refresh)


    def _on_local_slider_changed(self, v: int):
        self.sliceChanged.emit(self.plane, v)

    def refresh(self):
        if not self.volume.is_loaded():
            self.img_item.clear()
            self.slider.setMaximum(0)
            self.slider.setValue(0)
            return
        max_idx = self.volume.max_index(self.plane)
        self.slider.setMaximum(max_idx)
        # Use current index in VolumeData
        idx = self.volume.slices[self.plane]
        self.slider.setValue(idx)

        self.hdrSlider.blockSignals(True)
        self.hdrSlider.setMaximum(max_idx)     
        self.hdrSlider.setValue(idx)
        self.hdrSlider.blockSignals(False)


        mode = self.volume.display_mode
        if mode == "image_masked":
            # Âè™ÊòæÁ§∫ mask Âå∫ÂüüÁöÑÂéüÂõæ
            img = self.volume.render_image_masked_slice(self.plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))
                self.view.autoRange()
            # ËØ•Ê®°Âºè‰∏ã‰∏çÊòæÁ§∫ÂΩ©Ëâ≤ mask Ë¶ÜÁõñ
            self.mask_item.setVisible(False)
        else:
            # Ê≠£Â∏∏ÂéüÂõæ
            img = self.volume.render_slice(self.plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))
                self.view.autoRange()
            # Âè†Âä†/‰ªÖ mask / ‰ªÖÂõæ Áî±Ëøô‰∏™ÂáΩÊï∞Â§ÑÁêÜ
            self._update_mask_layer(idx)
                
        
        
        
    def _update_mask_layer(self, idx: int):
        mode = self.volume.display_mode
        has_mask = self.volume.has_mask()
        if mode == "image_only" or not has_mask:
            self.mask_item.setVisible(False)
            self.img_item.setVisible(True)
            return

        # Âè†Âä†Êàñ‰ªÖmask
        rgba = self.volume.render_mask_rgba_slice(self.plane, idx)
        if rgba is None:
            self.mask_item.setVisible(False)
            self.img_item.setVisible(True)
            return

        # Ê≥®ÊÑèÔºöRGBA ‰∏çËΩ¨ÁΩÆ‰ºöÂØºËá¥ÊñπÂêëÈîô‰ΩçÔºåËøôÈáå‰πüÂÅöËΩ¨ÁΩÆ
        self.mask_item.setImage(rgba.transpose(1, 0, 2), autoLevels=False)
        self.mask_item.setVisible(True)

        if mode == "mask_only":
            self.img_item.setVisible(False)
        else:  # overlay
            self.img_item.setVisible(True)


    # External API to set slice index and update image
    def set_slice(self, idx: int):
        if not self.volume.is_loaded():
            return
        max_idx = self.volume.max_index(self.plane)
        idx = int(np.clip(idx, 0, max_idx))
        if self.volume.slices[self.plane] != idx:
            self.volume.slices[self.plane] = idx
        # img = self.volume.render_slice(self.plane, idx)
        # if img is not None:
        #     self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))

        mode = self.volume.display_mode

        if mode == "image_masked":
            # Âè™ÊòæÁ§∫ mask Âå∫ÂüüÁöÑÂéüÂõæ
            img = self.volume.render_image_masked_slice(self.plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))
                self.view.autoRange()
            # ËØ•Ê®°Âºè‰∏ã‰∏çÊòæÁ§∫ÂΩ©Ëâ≤ mask Ë¶ÜÁõñ
            self.mask_item.setVisible(False)
        else:
            # Ê≠£Â∏∏ÂéüÂõæ
            img = self.volume.render_slice(self.plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))
                self.view.autoRange()
            # Âè†Âä†/‰ªÖ mask / ‰ªÖÂõæ Áî±Ëøô‰∏™ÂáΩÊï∞Â§ÑÁêÜ
            self._update_mask_layer(idx)


# class Volume3DPreview(QtWidgets.QFrame):
#     """ÊåâÈúÄÊ∏≤ÊüìÁöÑ3D‰ΩìËßÜÂõæ„ÄÇÈªòËÆ§ÊòæÁ§∫Âç†‰ΩçÂõæÔºõÁÇπÂáª Update ÂêéÊâçÁîüÊàê‰ΩìÁ¥†Âπ∂ÊòæÁ§∫ 3D„ÄÇ"""
#     zoomRequested = QtCore.Signal(object)

#     def __init__(self, volume: VolumeData, title="3D"):
#         super().__init__()
#         self.volume = volume
#         self.setFrameShape(QtWidgets.QFrame.StyledPanel)
#         self.setFrameShadow(QtWidgets.QFrame.Raised)

#         # --- Ê†áÈ¢òË°åÔºö3D | Update | üîç ---
#         top = QtWidgets.QHBoxLayout()
#         self.lbl = QtWidgets.QLabel(title)
#         self.lbl.setStyleSheet("font-weight: 600;")

#         self.btnUpdate = QtWidgets.QToolButton()
#         self.btnUpdate.setText("Update")
#         self.btnUpdate.setToolTip("Generate 3D preview with current mode")
#         self.btnUpdate.clicked.connect(self.regenerate)

#         self.btnZoom = QtWidgets.QToolButton()
#         self.btnZoom.setText("üîç")
#         self.btnZoom.setToolTip("Show this 3D view in the large view")
#         self.btnZoom.clicked.connect(lambda: self.zoomRequested.emit(self))

#         top.addWidget(self.lbl)
#         top.addStretch(1)
#         top.addWidget(self.btnUpdate)
#         top.addWidget(self.btnZoom)

#         # --- Âç†‰ΩçÈ°µÔºàPage 0ÔºâÔºöÊòæÁ§∫‰∏ÄÂº†ËΩªÈáèÂõæ ---
#         self.ph_glw = pg.GraphicsLayoutWidget()
#         self.ph_vb = self.ph_glw.addViewBox(lockAspect=True, enableMenu=False)
#         self.ph_vb.setMouseEnabled(x=False, y=False)
#         self.ph_img = pg.ImageItem()
#         self.ph_vb.addItem(self.ph_img)
#         # ÂàùÂßã levels Âõ∫ÂÆöÂà∞ [0,1]
#         self.ph_img.setLevels((0.0, 1.0))

#         # --- 3D È°µÔºàPage 1ÔºâÔºöGLViewWidget ---
#         self.view3d = gl.GLViewWidget()
#         self.view3d.opts["distance"] = 200
#         self.view3d.setBackgroundColor(30, 30, 30)
#         self.vol_item = None
#         self._last_rgba = None

#         # --- Â†ÜÊ†àÔºöÈªòËÆ§ÊòæÁ§∫Âç†‰ΩçÈ°µ ---
#         self.stack = QtWidgets.QStackedLayout()
#         self.stack.addWidget(self.ph_glw)   # index 0
#         self.stack.addWidget(self.view3d)   # index 1
#         self.stack.setCurrentIndex(0)

#         lay = QtWidgets.QVBoxLayout(self)
#         lay.setContentsMargins(6, 6, 6, 6)
#         lay.addLayout(top)
#         lay.addLayout(self.stack)

#         # Êï∞ÊçÆ/ÂèÇÊï∞ÂèòÂåñÔºöÂè™Âà∑Êñ∞Âç†‰ΩçÂõæÔºà‰∏çÂÅö 3D ÈáçÂª∫Ôºâ
#         self.volume.dataChanged.connect(self._refresh_placeholder)
#         self.volume.paramsChanged.connect(self._refresh_placeholder)

#         # È¶ñÊ¨°Âç†‰ΩçÂà∑Êñ∞
#         self._refresh_placeholder()

#     def _refresh_placeholder(self):
#         """Ê†πÊçÆÂΩìÂâçÊòæÁ§∫Ê®°ÂºèÔºåÁîüÊàê‰∏ÄÂº†ËΩªÈáèÁ∫ßÂç†‰ΩçÂõæÔºà‰∏çËß¶Âèë 3D ‰ΩìÊ∏≤ÊüìÔºâ„ÄÇ"""
#         if not self.volume.is_loaded():
#             self.ph_img.clear()
#             return

#         # Âèñ‰∏≠Èó¥Â±ÇÁöÑ Axial ÂàáÁâáÂÅöÁ§∫ÊÑèÔºõÂ∞ΩÈáè‰∏éÂΩìÂâçÊòæÁ§∫Ê®°Âºè‰∏ÄËá¥
#         z, _, _ = self.volume.shape_zyx()
#         idx = max(0, z // 2)

#         mode = self.volume.display_mode
#         if mode == "image_masked":
#             base = self.volume.render_image_masked_slice("Axial", idx)
#             if base is None:
#                 self.ph_img.clear(); return
#             self.ph_img.setImage(base.T, autoLevels=False, levels=(0.0, 1.0))
#             return

#         # ÂÖ∂‰ªñÊ®°ÂºèÔºöÂÖàÁîªÁÅ∞Â∫¶Â∫ï
#         base = self.volume.render_slice("Axial", idx)
#         if base is None:
#             self.ph_img.clear(); return
#         self.ph_img.setImage(base.T, autoLevels=False, levels=(0.0, 1.0))

#         # Ëã•ÈúÄË¶ÅÂè†ÂΩ©Ëâ≤ mask
#         if mode in ("overlay", "mask_only") and self.volume.has_mask():
#             rgba = self.volume.render_mask_rgba_slice("Axial", idx)  # (H,W,4) uint8
#             if rgba is not None:
#                 # ÊääÂΩ©Ëâ≤ mask Áõ¥Êé•ÁîªÂà∞Âêå‰∏Ä ImageItem ‰∏ä‰ºöË¢´Ë¶ÜÁõñÔºõ
#                 # ËøôÈáåÂÅö‰∏ÄÊ¨°ÁÆÄÂçïÁöÑ alpha ÂêàÊàêÔºåÂæóÂà∞‰∏ÄÂº† RGB ÁÅ∞Â∫¶Ôºà0~1Ôºâ
#                 over = self._alpha_blend_gray_rgba(base, rgba)  # ËøîÂõû 0~1 float
#                 self.ph_img.setImage(over.T, autoLevels=False, levels=(0.0, 1.0))
#         # Ëã•ÊòØ image_onlyÔºåÂ∞±Âè™ÊòæÁ§∫ÁÅ∞Â∫¶
#         self.ph_vb.autoRange()

#     @staticmethod
#     def _alpha_blend_gray_rgba(gray01: np.ndarray, rgba: np.ndarray) -> np.ndarray:
#         """Êää [0,1] ÁÅ∞Â∫¶Âõæ‰∏é uint8 RGBA ÂÅöÂâçÊôØË¶ÜÁõñÔºåËøîÂõû [0,1] ÁöÑËøë‰ººÂêàÊàêÁªìÊûúÔºàÂè™‰∏∫Âç†‰ΩçÊòæÁ§∫Ôºâ„ÄÇ"""
#         g = np.clip(gray01, 0.0, 1.0).astype(np.float32)
#         rgb = rgba[..., :3].astype(np.float32) / 255.0
#         a   = rgba[..., 3].astype(np.float32) / 255.0
#         # ÁÆÄÂçï"over"ÂêàÊàêÔºöout = fg*a + bg*(1-a)
#         out_rgb = rgb * a[..., None] + g[..., None] * (1.0 - a[..., None])
#         # Âèñ‰∫ÆÂ∫¶Ëøë‰ººÔºàÂπ≥ÂùáÔºâËΩ¨ÂõûÁÅ∞Â∫¶‰ª•ËäÇÁúÅÁªòÂà∂
#         out_g = out_rgb.mean(axis=-1)
#         return np.clip(out_g, 0.0, 1.0).astype(np.float32)


#     def clear(self):
#         if self.vol_item is not None:
#             try:
#                 self.view3d.removeItem(self.vol_item)
#             except Exception:
#                 pass
#             self.vol_item = None
#         self._last_rgba = None
#         self.stack.setCurrentIndex(0)  # ÂõûÂà∞Âç†‰ΩçÈ°µ

#     def regenerate(self):
#         if not self.volume.is_loaded():
#             self.clear()
#             return
#         rgba = self._build_rgba_from_current()
#         self._last_rgba = rgba

#         if self.vol_item is not None:
#             try:
#                 self.view3d.removeItem(self.vol_item)
#             except Exception:
#                 pass
#             self.vol_item = None

#         self.vol_item = gl.GLVolumeItem(rgba, smooth=True)
#         self.vol_item.setGLOptions('translucent')
#         self.view3d.addItem(self.vol_item)
#         self.stack.setCurrentIndex(1) 

#     def export_rgba(self):
#         """ÊääÊúÄËøë‰∏ÄÊ¨°ÁîüÊàêÁöÑ RGBA ‰ΩìÁ¥†ÂØºÂá∫Ôºå‰æõÂè≥‰æß 3D Â§ßÂõæ‰ΩøÁî®„ÄÇ"""
#         return self._last_rgba

#     # ---------- helpers ----------
#     def _normalize_volume(self, vol: np.ndarray) -> np.ndarray:
#         L, W = self.volume.window_level, self.volume.window_width
#         if L is not None and W is not None:
#             lo, hi = float(L) - float(W) * 0.5, float(L) + float(W) * 0.5
#         else:
#             gmin = self.volume._gmin if self.volume._gmin is not None else float(np.nanmin(vol))
#             gmax = self.volume._gmax if self.volume._gmax is not None else float(np.nanmax(vol))
#             if not np.isfinite(gmin) or not np.isfinite(gmax) or gmax <= gmin:
#                 gmin, gmax = 0.0, 1.0
#             lo, hi = gmin, gmax
#         out = (vol.astype(np.float32) - lo) / max(1e-6, (hi - lo))
#         out = np.clip(out, 0.0, 1.0)
#         return np.nan_to_num(out, nan=0.0, posinf=1.0, neginf=0.0)

#     def _build_rgba_from_current(self) -> np.ndarray:
#         """Ê†πÊçÆ display_mode ÊûÑÂª∫ (X,Y,Z,4) RGBA ‰ΩìÁ¥†„ÄÇ"""
#         vol = self.volume._vol
#         norm = self._normalize_volume(vol)               # (Z,Y,X) in [0,1]
#         mode = self.volume.display_mode
#         has_mask = self.volume.has_mask()

#         if mode == "image_only" or (mode == "image_masked" and not has_mask):
#             # ÁÅ∞Â∫¶‰ΩìÁ¥† + Âº∫Â∫¶alpha
#             rgb = (norm * 255).astype(np.ubyte)
#             a   = (norm * 0.6 * 255).astype(np.ubyte)

#             rgba = np.stack([rgb, rgb, rgb, a], axis=-1)         # (Z,Y,X,4)

#         elif mode == "image_masked" and has_mask:
#             lab = self.volume._mask
#             m = (lab > 0).astype(np.float32)
#             rgb = (norm * m * 255).astype(np.ubyte)
#             a   = (norm * m * 0.6 * 255).astype(np.ubyte)
#             rgba = np.stack([rgb, rgb, rgb, a], axis=-1)

#         elif mode == "mask_only" and has_mask:
#             lab = np.asarray(self.volume._mask, dtype=np.int32)   # (Z,Y,X)
#             lut = self.volume._lut_colors
#             K = lut.shape[0]
#             lab_clip = np.clip(lab, 0, K-1)
#             rgba = lut[lab_clip].astype(np.ubyte)                 # (Z,Y,X,4)
#             # ÂÖ®Â±Ä alphaÔºàÂè†‰∏ÄÂ±ÇÁ≥ªÊï∞ÔºåËÆ©‰ΩìÊ∏≤ÊüìÊõ¥ÊüîÂíåÔºâ
#             if self.volume.mask_alpha < 1.0:
#                 a = (rgba[..., 3].astype(np.float32) * self.volume.mask_alpha).clip(0,255).astype(np.ubyte)
#                 rgba = rgba.copy()
#                 rgba[..., 3] = a

#         else:
#             # overlay: Áî®ÁÅ∞Â∫¶‰ΩúÂ∫ïÔºåmask>0 Âå∫ÂüüÂæÆÂæÆ‰∏äËâ≤/Âä†ÈÄèÊòéÂ∫¶
#             rgb = (norm * 255).astype(np.ubyte)
#             a   = (norm * 0.4 * 255).astype(np.ubyte)      # Â∫ïÂ±Ç alpha
#             rgba = np.stack([rgb, rgb, rgb, a], axis=-1)

#             if has_mask and self.volume._lut_colors is not None:
#                 lab = np.asarray(self.volume._mask, dtype=np.int32)
#                 K = self.volume._lut_colors.shape[0]
#                 lab_clip = np.clip(lab, 0, K-1)
#                 color = self.volume._lut_colors[lab_clip]  # (Z,Y,X,4)
#                 # ÁÆÄÂçïÊ∑∑Ëâ≤ÔºömaskÂÉèÁ¥†Êèê‰∫ÆÂπ∂Â¢ûÂä†alpha
#                 mask_on = (lab_clip > 0)
#                 rgba = rgba.copy()
#                 rgba[..., 0][mask_on] = np.maximum(rgba[..., 0][mask_on], color[..., 0][mask_on])
#                 rgba[..., 1][mask_on] = np.maximum(rgba[..., 1][mask_on], color[..., 1][mask_on])
#                 rgba[..., 2][mask_on] = np.maximum(rgba[..., 2][mask_on], color[..., 2][mask_on])
#                 add_a = int(255 * 0.25 * self.volume.mask_alpha)
#                 rgba[..., 3][mask_on] = np.clip(rgba[..., 3][mask_on].astype(np.int16) + add_a, 0, 255).astype(np.ubyte)

#         # (Z,Y,X,4) -> (X,Y,Z,4)
#         rgba = np.transpose(rgba, (2, 1, 0, 3)).copy(order='C')
#         return rgba

class Volume3DPreview(QtWidgets.QFrame):
    """ÁúüÊ≠£ÁöÑ3DÂ∞èÈ¢ÑËßàÔºöÈªòËÆ§Á©∫ÔºàÈªëÂ∫ïÔºå‰∏çÊ∏≤ÊüìÔºâÔºõÁÇπÂáª Update ÂêéÂú®Â∞èÁ™óÁõ¥Êé•‰ΩìÊ∏≤Êüì„ÄÇ"""
    zoomRequested = QtCore.Signal(object)   # ‰º†Ëá™Ë∫´ÂØπË±°Ôºå‰æø‰∫é MainWindow ÊîæÂ§ß

    def __init__(self, volume: VolumeData, title="3D"):
        super().__init__()
        self.volume = volume
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)

        # --- Ê†áÈ¢òË°åÔºö3D | Update | üîç ---
        top = QtWidgets.QHBoxLayout()
        self.lbl = QtWidgets.QLabel(title)
        self.lbl.setStyleSheet("font-weight: 600;")

        self.btnUpdate = QtWidgets.QToolButton()
        self.btnUpdate.setText("Update")
        self.btnUpdate.setToolTip("Generate 3D preview with current mode")
        self.btnUpdate.clicked.connect(self.regenerate)

        self.btnZoom = QtWidgets.QToolButton()
        self.btnZoom.setText("üîç")
        self.btnZoom.setToolTip("Show this 3D view in the large view")
        self.btnZoom.clicked.connect(lambda: self.zoomRequested.emit(self))

        top.addWidget(self.lbl)
        top.addStretch(1)
        top.addWidget(self.btnUpdate)
        top.addWidget(self.btnZoom)

        # --- 3D Â∞èÁ™óÔºàÂßãÁªàÊòØ GLViewWidgetÔºâ ---
        self.view3d = gl.GLViewWidget()
        self.view3d.opts["distance"] = 200
        self.view3d.setBackgroundColor(30, 30, 30)
        # ÂÖÅËÆ∏Áî®Êà∑Âú®Â∞èÁ™óÈáåÁî®Èº†Ê†áÊóãËΩ¨/Áº©Êîæ
        self.view3d.setMinimumHeight(160)

        self.vol_item = None          # GLVolumeItem
        self._last_rgba = None        # ÊúÄËøë‰∏ÄÊ¨°ÁîüÊàêÁöÑ RGBA ‰ΩìÁ¥† (X,Y,Z,4)

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addLayout(top)
        lay.addWidget(self.view3d)

        # Êï∞ÊçÆ/ÂèÇÊï∞ÂèòÂåñÔºö‰ªÖÊ∏ÖÁ©∫ÔºàÊåâÈúÄÊ∏≤ÊüìÁ≠ñÁï•Ôºå‰∏çËá™Âä®ÈáçÂª∫Ôºâ
        self.volume.dataChanged.connect(self.clear)
        self.volume.paramsChanged.connect(self.clear)

    def clear(self):
        if self.vol_item is not None:
            try:
                self.view3d.removeItem(self.vol_item)
            except Exception:
                pass
            self.vol_item = None
        self._last_rgba = None
        # ‰øùÁïôÈªëÂ∫ïÁ©∫ËßÜÂõæÂç≥ÂèØ

    def regenerate(self):
        """ÊåâÂΩìÂâç VolumeData ÁöÑ WL/WW + display_mode ÁîüÊàê 3D ‰ΩìÁ¥†ÔºåÂπ∂ÊòæÁ§∫Âú®Â∞èÁ™ó„ÄÇ"""
        if not self.volume.is_loaded():
            self.clear()
            return

        rgba = self._build_rgba_from_current()
        self._last_rgba = rgba

        # ÊõøÊç¢ GLVolumeItem
        if self.vol_item is not None:
            try:
                self.view3d.removeItem(self.vol_item)
            except Exception:
                pass
            self.vol_item = None

        self.vol_item = gl.GLVolumeItem(rgba, smooth=True)
        self.vol_item.setGLOptions('translucent')
        self.view3d.addItem(self.vol_item)

    def export_rgba(self):
        """ÊääÊúÄËøë‰∏ÄÊ¨°ÁîüÊàêÁöÑ RGBA ‰ΩìÁ¥†ÂØºÂá∫Ôºå‰æõÂè≥‰æß 3D Â§ßÂõæ‰ΩøÁî®„ÄÇ"""
        return self._last_rgba

    # ---------- helpers ----------
    def _normalize_volume(self, vol: np.ndarray) -> np.ndarray:
        L, W = self.volume.window_level, self.volume.window_width
        if L is not None and W is not None:
            lo, hi = float(L) - float(W) * 0.5, float(L) + float(W) * 0.5
        else:
            gmin = self.volume._gmin if self.volume._gmin is not None else float(np.nanmin(vol))
            gmax = self.volume._gmax if self.volume._gmax is not None else float(np.nanmax(vol))
            if not np.isfinite(gmin) or not np.isfinite(gmax) or gmax <= gmin:
                gmin, gmax = 0.0, 1.0
            lo, hi = gmin, gmax
        out = (vol.astype(np.float32) - lo) / max(1e-6, (hi - lo))
        out = np.clip(out, 0.0, 1.0)
        return np.nan_to_num(out, nan=0.0, posinf=1.0, neginf=0.0)

    def _build_rgba_from_current(self) -> np.ndarray:
        """Ê†πÊçÆ display_mode ÊûÑÂª∫ (X,Y,Z,4) RGBA ‰ΩìÁ¥†„ÄÇ"""
        vol = self.volume._vol
        norm = self._normalize_volume(vol)               # (Z,Y,X) in [0,1]
        mode = self.volume.display_mode
        has_mask = self.volume.has_mask()

        if mode == "image_only" or (mode == "image_masked" and not has_mask):
            rgb = (norm * 255).astype(np.ubyte)
            a   = (norm * 0.6 * 255).astype(np.ubyte)
            rgba = np.stack([rgb, rgb, rgb, a], axis=-1)

        elif mode == "image_masked" and has_mask:
            lab = self.volume._mask
            m = (lab > 0).astype(np.float32)
            rgb = (norm * m * 255).astype(np.ubyte)
            a   = (norm * m * 0.6 * 255).astype(np.ubyte)
            rgba = np.stack([rgb, rgb, rgb, a], axis=-1)

        elif mode == "mask_only" and has_mask:
            lab = np.asarray(self.volume._mask, dtype=np.int32)
            lut = self.volume._lut_colors
            K = lut.shape[0]
            lab_clip = np.clip(lab, 0, K-1)
            rgba = lut[lab_clip].astype(np.ubyte)
            if self.volume.mask_alpha < 1.0:
                a = (rgba[..., 3].astype(np.float32) * self.volume.mask_alpha).clip(0,255).astype(np.ubyte)
                rgba = rgba.copy(); rgba[..., 3] = a

        else:  # overlay
            rgb = (norm * 255).astype(np.ubyte)
            a   = (norm * 0.4 * 255).astype(np.ubyte)
            rgba = np.stack([rgb, rgb, rgb, a], axis=-1)
            if has_mask and self.volume._lut_colors is not None:
                lab = np.asarray(self.volume._mask, dtype=np.int32)
                K = self.volume._lut_colors.shape[0]
                lab_clip = np.clip(lab, 0, K-1)
                color = self.volume._lut_colors[lab_clip]  # (Z,Y,X,4)
                mask_on = (lab_clip > 0)
                rgba = rgba.copy()
                rgba[..., 0][mask_on] = np.maximum(rgba[..., 0][mask_on], color[..., 0][mask_on])
                rgba[..., 1][mask_on] = np.maximum(rgba[..., 1][mask_on], color[..., 1][mask_on])
                rgba[..., 2][mask_on] = np.maximum(rgba[..., 2][mask_on], color[..., 2][mask_on])
                add_a = int(255 * 0.25 * self.volume.mask_alpha)
                rgba[..., 3][mask_on] = np.clip(rgba[..., 3][mask_on].astype(np.int16) + add_a, 0, 255).astype(np.ubyte)

        # (Z,Y,X,4) -> (X,Y,Z,4)
        rgba = np.transpose(rgba, (2, 1, 0, 3)).copy(order='C')
        return rgba


class DetailView(QtWidgets.QFrame):
    """Large right-side view that mirrors and controls the active preview."""
    def __init__(self, volume: VolumeData):
        super().__init__()
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)
        self.volume = volume
        self.volume.paramsChanged.connect(self._rerender_active)
        self.active_plane = None  # which preview we are mirroring

        # Header
        top = QtWidgets.QHBoxLayout()
        self.title = QtWidgets.QLabel("Detail ‚Äî (none)")
        self.title.setStyleSheet("font-weight: 600; font-size: 14px;")

        # Êñ∞Â¢ûÔºöÊîæÂ§ß/Áº©Â∞èÊåâÈíÆ
        self.btnZoomIn = QtWidgets.QToolButton()
        self.btnZoomIn.setText("+")                       # ‰πüÂèØÁî®ÂõæÊ†á
        self.btnZoomIn.setToolTip("Zoom In")
        self.btnZoomIn.clicked.connect(self._zoom_in)

        self.btnZoomOut = QtWidgets.QToolButton()
        self.btnZoomOut.setText("‚àí")                      # Ê≥®ÊÑèÊòØÂ≠óÁ¨¶ '‚àí' ÊàñËÄÖÁî® '-'
        self.btnZoomOut.setToolTip("Zoom Out")
        self.btnZoomOut.clicked.connect(self._zoom_out)


        self.btnReset = QtWidgets.QToolButton()
        self.btnReset.setText("Reset View")
        self.btnReset.clicked.connect(self._reset_view)


        top.addWidget(self.title)
        top.addStretch(1)
        top.addWidget(self.btnZoomOut)
        top.addWidget(self.btnZoomIn)
        top.addWidget(self.btnReset)


        # Graphics
        self.glw = pg.GraphicsLayoutWidget()
        self.view = self.glw.addViewBox(lockAspect=True, enableMenu=False)
        self.view.setMouseEnabled(x=True, y=True)
        self.img_item = pg.ImageItem()
        self.view.addItem(self.img_item)
        self.img_item.setLevels((0.0, 1.0))



        self.mask_item = pg.ImageItem()
        self.mask_item.setZValue(10)
        self.view.addItem(self.mask_item)
        
        # Layout
        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addLayout(top)
        lay.addWidget(self.glw)

        # For syncing: a handle to the preview's ViewBox (set when promoted)
        self._linked_preview_vb = None
        # ÈîÆÁõòÂø´Êç∑ÈîÆÔºöCtrl/‚åò + Âä†/ÂáèÔºåÂíå Ctrl/‚åò + 0 ÈáçÁΩÆ
        QShortcut(QKeySequence.ZoomIn,  self, activated=self._zoom_in)
        QShortcut(QKeySequence.ZoomOut, self, activated=self._zoom_out)
        QShortcut(QKeySequence("Ctrl+0"), self, activated=self._reset_view)
        QShortcut(QKeySequence("Meta+0"), self, activated=self._reset_view)  # macOS


        # Connect range change to push back to preview
        self.view.sigRangeChanged.connect(self._on_range_changed)



    def _on_range_changed(self, vb, ranges):
        # Mirror the pan/zoom to the linked preview viewbox
        if self._linked_preview_vb is not None:
            x_rng, y_rng = self.view.viewRange()
            # Block signals to avoid feedback loops
            self._linked_preview_vb.blockSignals(True)
            self._linked_preview_vb.setXRange(*x_rng, padding=0)
            self._linked_preview_vb.setYRange(*y_rng, padding=0)
            self._linked_preview_vb.blockSignals(False)

    def _reset_view(self):
        self.view.autoRange()
        if self._linked_preview_vb is not None:
            self._linked_preview_vb.autoRange()

    def _zoom_in(self):
        self._zoom(factor=0.8)   # Êï∞ÂÄº <1 Ë°®Á§∫ÊîæÂ§ßÔºàËåÉÂõ¥ÂèòÂ∞èÔºâ

    def _zoom_out(self):
        self._zoom(factor=1.25)  # Êï∞ÂÄº >1 Ë°®Á§∫Áº©Â∞èÔºàËåÉÂõ¥ÂèòÂ§ßÔºâ

    def _zoom(self, factor: float):
        # Âü∫‰∫éÂΩìÂâçÂèØËßÜËåÉÂõ¥Êåâ‰∏≠ÂøÉÁº©ÊîæÔºå‰øùÊåÅÁ∫µÊ®™ÊØî/ÂêåÊ≠•Âà∞È¢ÑËßà
        x_rng, y_rng = self.view.viewRange()      # [(xmin, xmax), (ymin, ymax)]
        cx = 0.5 * (x_rng[0] + x_rng[1])
        cy = 0.5 * (y_rng[0] + y_rng[1])
        w = (x_rng[1] - x_rng[0]) * factor
        h = (y_rng[1] - y_rng[0]) * factor
        self.view.setXRange(cx - w/2.0, cx + w/2.0, padding=0)
        self.view.setYRange(cy - h/2.0, cy + h/2.0, padding=0)


    def _rerender_active(self):
        if self.active_plane is None:
            return
        idx = self.volume.slices[self.active_plane]

        # # ÂéüÂõæ
        # img = self.volume.render_slice(self.active_plane, idx)
        # if img is not None:
        #     self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))

        mode = self.volume.display_mode

        if mode == "image_masked":
            img = self.volume.render_image_masked_slice(self.active_plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))
            # ‰∏çÊòæÁ§∫ÂΩ©Ëâ≤ mask
            self.mask_item.setVisible(False)
            self.img_item.setVisible(True)
            return
        else:
            # ÂéüÂõæÔºàÊ≠£Â∏∏Ôºâ
            img = self.volume.render_slice(self.active_plane, idx)
            if img is not None:
                self.img_item.setImage(img.T, autoLevels=False, levels=(0.0, 1.0))


        # mask
        mode = self.volume.display_mode
        has_mask = self.volume.has_mask()
        if mode == "image_only" or not has_mask:
            self.mask_item.setVisible(False)
            self.img_item.setVisible(True)
            return

        rgba = self.volume.render_mask_rgba_slice(self.active_plane, idx)
        if rgba is None:
            self.mask_item.setVisible(False)
            self.img_item.setVisible(True)
            return

        self.mask_item.setImage(rgba.transpose(1, 0, 2), autoLevels=False)
        self.mask_item.setVisible(True)
        if mode == "mask_only":
            self.img_item.setVisible(False)
        else:
            self.img_item.setVisible(True)


    def promote_from(self, plane: str, src_imgitem: pg.ImageItem, src_viewbox: pg.ViewBox):
        self.active_plane = plane
        self.title.setText(f"Detail ‚Äî {plane}")
        # Âè™Áî®Áªü‰∏ÄÊ∏≤ÊüìÔºå‰øùËØÅ‰∏éÈ¢ÑËßà‰∏ÄËá¥
        self._rerender_active()
        self.view.autoRange()
        # ÈìæÊé•ËåÉÂõ¥
        self._linked_preview_vb = src_viewbox
        x_rng, y_rng = src_viewbox.viewRange()
        self.view.setXRange(*x_rng, padding=0)
        self.view.setYRange(*y_rng, padding=0)


class DetailView3D(QtWidgets.QFrame):
    """Âè≥‰æß 3D Â§ßÂõæÔºöÂ§çÁî®‰∏éÂ∞èÂõæÁõ∏ÂêåÁöÑ RGBA ‰ΩìÁ¥†„ÄÇ"""
    def __init__(self):
        super().__init__()
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)

        top = QtWidgets.QHBoxLayout()
        self.title = QtWidgets.QLabel("Detail ‚Äî 3D")
        self.title.setStyleSheet("font-weight: 600; font-size: 14px;")

        # Êñ∞Â¢ûÔºöÊîæÂ§ß/Áº©Â∞èÊåâÈíÆ
        self.btnZoomIn = QtWidgets.QToolButton()
        self.btnZoomIn.setText("+")
        self.btnZoomIn.setToolTip("Zoom In")
        self.btnZoomIn.clicked.connect(self._zoom_in)

        self.btnZoomOut = QtWidgets.QToolButton()
        self.btnZoomOut.setText("‚àí")
        self.btnZoomOut.setToolTip("Zoom Out")
        self.btnZoomOut.clicked.connect(self._zoom_out)

        self.btnReset = QtWidgets.QToolButton()
        self.btnReset.setText("Reset View")
        self.btnReset.clicked.connect(self._reset_view)

        top.addWidget(self.title)
        top.addStretch(1)
        top.addWidget(self.btnZoomOut)
        top.addWidget(self.btnZoomIn)
        top.addWidget(self.btnReset)

        self.view = gl.GLViewWidget()
        self.view.opts["distance"] = 200
        self.view.setBackgroundColor(30, 30, 30)

        self.vol_item = None

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addLayout(top)
        lay.addWidget(self.view)

        # ÈîÆÁõòÂø´Êç∑ÈîÆ
        QShortcut(QKeySequence.ZoomIn,  self, activated=self._zoom_in)
        QShortcut(QKeySequence.ZoomOut, self, activated=self._zoom_out)
        QShortcut(QKeySequence("Ctrl+0"), self, activated=self._reset_view)
        QShortcut(QKeySequence("Meta+0"), self, activated=self._reset_view)  # macOS


    def _reset_view(self):
        self.view.opts["distance"] = 200
        self.view.orbit(0, 0)

    def show_rgba(self, rgba: np.ndarray):
        if rgba is None:
            return
        if self.vol_item is not None:
            try:
                self.view.removeItem(self.vol_item)
            except Exception:
                pass
            self.vol_item = None
        self.vol_item = gl.GLVolumeItem(rgba, smooth=True)
        self.vol_item.setGLOptions('translucent')
        self.view.addItem(self.vol_item)
        self._reset_view()
        
    def _reset_view(self):
        # ÈáçÁΩÆÂà∞ÂêàÈÄÇÁöÑËßÇÂØüË∑ùÁ¶ªÂíåÂßøÊÄÅ
        self.view.opts["distance"] = 200
        # orbit(azimuthDelta, elevationDelta) ‚Äî‚Äî ÂΩíÈõ∂ÂßøÊÄÅ
        self.view.orbit(0, 0)

    def _zoom(self, factor: float):
        """ÈÄöËøáË∞ÉËäÇÁõ∏Êú∫ distance ÂÆûÁé∞ÊîæÂ§ß/Áº©Â∞è„ÄÇfactor<1ÊîæÂ§ßÔºå>1Áº©Â∞è"""
        d0 = float(self.view.opts.get("distance", 200))
        # Á∫¶ÊùüË∑ùÁ¶ªËåÉÂõ¥ÔºåÈÅøÂÖçÈ£ûÂÖ•ÊàñÈ£ûÂá∫ËøáËøú
        MIN_D, MAX_D = 5.0, 5000.0
        d1 = float(np.clip(d0 * factor, MIN_D, MAX_D))
        self.view.setCameraPosition(distance=d1)   # ÂÆòÊñπÊé®ËçêÊé•Âè£
        # ‰πüÂèØ‰ª•Ôºöself.view.opts["distance"] = d1

    def _zoom_in(self):
        self._zoom(0.8)    # ÊîæÂ§ßÔºàdistance ÂèòÂ∞èÔºâ

    def _zoom_out(self):
        self._zoom(1.25)   # Áº©Â∞èÔºàdistance ÂèòÂ§ßÔºâ



class LeftToolbar(QtWidgets.QFrame):
    """Left-side vertical toolbar with file open and basic controls."""
    openRequested = QtCore.Signal()
    openMaskRequested = QtCore.Signal()


    def __init__(self):
        super().__init__()
        self.setFixedWidth(160)
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(8, 8, 8, 8)

        title = QtWidgets.QLabel("Tools")
        title.setStyleSheet("font-weight: 700; font-size: 14px;")
        lay.addWidget(title)

        self.btnOpen = QtWidgets.QPushButton("Open Image")
        self.btnOpen.clicked.connect(self.openRequested.emit)
        lay.addWidget(self.btnOpen)

        self.btnOpenMask = QtWidgets.QPushButton("Open Mask")
        self.btnOpenMask.clicked.connect(lambda: self.openMaskRequested.emit())
        lay.addWidget(self.btnOpenMask)

        
        self.spnLevel = QtWidgets.QDoubleSpinBox()
        self.spnLevel.setRange(-2000, 3000); self.spnLevel.setValue(40.0); self.spnLevel.setDecimals(1)
        self.spnWidth = QtWidgets.QDoubleSpinBox()
        self.spnWidth.setRange(1.0, 5000.0); self.spnWidth.setValue(80.0); self.spnWidth.setDecimals(1)


        row1 = QtWidgets.QHBoxLayout()
        row1.addWidget(QtWidgets.QLabel("Level"))
        row1.addWidget(self.spnLevel, 1)
        lay.addLayout(row1)

        row2 = QtWidgets.QHBoxLayout()
        row2.addWidget(QtWidgets.QLabel("Width"))
        row2.addWidget(self.spnWidth, 1)
        lay.addLayout(row2)

        # ÈÄèÊòéÂ∫¶
        rowA = QtWidgets.QHBoxLayout()
        rowA.addWidget(QtWidgets.QLabel("Mask Œ±"))
        self.sldMaskAlpha = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.sldMaskAlpha.setRange(0, 100)
        self.sldMaskAlpha.setValue(int(0.6 * 100))
        rowA.addWidget(self.sldMaskAlpha, 1)
        lay.addLayout(rowA)

        # ÊòæÁ§∫Ê®°ÂºèÔºàÂçïÈÄâÔºâ
        self.grpMode = QtWidgets.QButtonGroup(self)
        radOverlay  = QtWidgets.QRadioButton("Image+Mask")
        radImage    = QtWidgets.QRadioButton("Image Only")
        radMaskOnly = QtWidgets.QRadioButton("Mask Only")
        radImageMasked = QtWidgets.QRadioButton("Image (masked)")


        radOverlay.setChecked(True)
        self.grpMode.addButton(radOverlay, 0)
        self.grpMode.addButton(radImage, 1)
        self.grpMode.addButton(radMaskOnly, 2)
        self.grpMode.addButton(radImageMasked, 3)
        lay.addWidget(radOverlay)
        lay.addWidget(radImage)
        lay.addWidget(radMaskOnly)
        lay.addWidget(radImageMasked)

        lay.addStretch(1)

class MiddleColumn(QtWidgets.QFrame):
    """Center column: three previews stacked vertically + a single global slice slider + plane selector."""
    # zoomRequested = QtCore.Signal(str)  # plane
    zoomRequested = QtCore.Signal(object) 
    globalSliceChanged = QtCore.Signal(str, int)  # (plane, idx)

    def __init__(self, volume: VolumeData):
        super().__init__()
        self.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.setFrameShadow(QtWidgets.QFrame.Raised)
        self.volume = volume

        self.view_specs = [
            {"name": "3D",       "factory": lambda: Volume3DPreview(self.volume, "3D")},
            {"name": "Axial",    "factory": lambda: ImagePreview("Axial", self.volume)},
            {"name": "Coronal",  "factory": lambda: ImagePreview("Coronal", self.volume)},
            {"name": "Sagittal", "factory": lambda: ImagePreview("Sagittal", self.volume)},
        ]
        self.viewport_size = len(self.view_specs)  # 4      # ‰∏ÄÂ±èÊòæÁ§∫Âá†‰∏™È¢ÑËßà
        self.view_offset = 0        # ÂΩìÂâçÁ™óÂè£Ëµ∑ÂßãÁ¥¢Âºï


        # ÂÆû‰æãÂåñÂÖ®ÈÉ®È¢ÑËßàÔºå‰ΩÜ‰∏çÂÖ®ÈÉΩÊîæËøõÂèØËßÅÂ∏ÉÂ±Ä
        self.all_previews = [spec["factory"]() for spec in self.view_specs]
        self.preview3d = None
        for prev in self.all_previews:
            # ÈÄè‰º† üîç
            if hasattr(prev, "zoomRequested"):
                prev.zoomRequested.connect(self.zoomRequested)
            # Êâæ 3D
            if isinstance(prev, Volume3DPreview):
                self.preview3d = prev

        # ÊääÊâÄÊúâ 2D È¢ÑËßàÁöÑ update3DRequested -> 3D.regenerate
        # for prev in self.all_previews:
        #     if isinstance(prev, ImagePreview):
        #         prev.update3DRequested.connect(lambda: self.preview3d and self.preview3d.regenerate())

        # ÂèØËßÅÂÆπÂô®ÔºàÂûÇÁõ¥Ôºâ
        self.container = QtWidgets.QWidget()
        self.container_vbox = QtWidgets.QVBoxLayout(self.container)
        self.container_vbox.setContentsMargins(6, 6, 6, 6)
        self.container_vbox.setSpacing(6)

        # ÂÖàÂ°´ÂÖÖÂèØËßÅÁ™óÂè£ÔºàÂâç viewport_size ‰∏™Ôºâ
        self._rebuild_visible_previews()

        # Â∑¶‰æßÊªöÂä®Âå∫ÂüüÔºåÂåÖË£πÂèØËßÅÂÆπÂô®
        self.scroll = QtWidgets.QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(self.container)

        # ---- Âè≥‰æßÔºöÁ´ñÁõ¥ÂÖ®Â±ÄÊªëÊù°ÔºåÁî®‰∫éÂàÜÈ°µÊªöÂä®È¢ÑËßàÂàóË°® ----
        self.sldViewport = QtWidgets.QSlider(QtCore.Qt.Vertical)
        self.sldViewport.setMinimum(0)
        self._update_viewport_slider_range()        # ËÆæÁΩÆÊúÄÂ§ßÂÄº
        self.sldViewport.setValue(self.view_offset)
        self.sldViewport.valueChanged.connect(self._on_viewport_slider)

        # # È°∂ÈÉ®ÔºöÂπ≥Èù¢ÈÄâÊã© + ÔºàÂ¶ÇÊûú‰Ω†ÊöÇÊó∂‰∏çÈúÄË¶ÅÂèØÁßªÈô§Ôºâ + ËøôÈáå‰∏çÂÜç‰Ωú‰∏∫‚Äúslice ÂÖ®Â±ÄÊªëÊù°‚Äù
        # self.cmbPlane = QtWidgets.QComboBox()
        # self.cmbPlane.addItems([spec["name"] for spec in self.view_specs])
        # self.cmbPlane.setVisible(False)  # Â¶Ç‰∏çÈúÄË¶ÅÂèØÈöêËóè

        # ---- ‰∏≠ÂàóÊÄªÂ∏ÉÂ±ÄÔºöÂ∑¶Ëæπ scrollÔºàÊòæÁ§∫È¢ÑËßàÔºâÔºåÂè≥ËæπÁ´ñÁõ¥ slider ----
        col = QtWidgets.QHBoxLayout()
        col.setContentsMargins(0, 0, 0, 0)
        col.setSpacing(6)
        col.addWidget(self.scroll, 1)
        col.addWidget(self.sldViewport)  # Âè≥‰æß

        lay = QtWidgets.QVBoxLayout(self)
        lay.setContentsMargins(6, 6, 6, 6)
        lay.addLayout(col, 1)

        # Êï∞ÊçÆÊîπÂèòÊó∂ÔºåÂà∑Êñ∞ÂèØËßÅÈ¢ÑËßàÔºàËÄå‰∏çÊòØÈáçÂª∫ÂÖ®ÈÉ®Ôºâ
        self.volume.dataChanged.connect(self._refresh_visible)


    def _update_viewport_slider_range(self):
        n = len(self.all_previews)
        max_off = max(0, n - self.viewport_size)
        self.sldViewport.setMaximum(max_off)
        self.sldViewport.setEnabled(max_off > 0)
        self.sldViewport.setSingleStep(1)
        self.sldViewport.setPageStep(1)


    def _rebuild_visible_previews(self):
        # ÂÖàÊ∏ÖÁ©∫ÂÆπÂô®
        while self.container_vbox.count():
            item = self.container_vbox.takeAt(0)
            w = item.widget()
            if w is not None:
                w.setParent(None)

        # Âèñ [view_offset, view_offset + viewport_size) Ëøô‰∏ÄÊÆµ
        start = int(self.view_offset)
        end = min(start + self.viewport_size, len(self.all_previews))
        for i in range(start, end):
            self.container_vbox.addWidget(self.all_previews[i])
        self.container_vbox.addStretch(1)

    def _on_viewport_slider(self, v: int):
        self.view_offset = int(v)
        self._rebuild_visible_previews()

    def _refresh_visible(self):
        # Êï∞ÊçÆÊõ¥Êñ∞Êó∂ÔºåÂà∑Êñ∞‚ÄúÂΩìÂâçÂèØËßÅ‚ÄùÁöÑÈ¢ÑËßà
        start = int(self.view_offset)
        end = min(start + self.viewport_size, len(self.all_previews))
        for i in range(start, end):
            self.all_previews[i].refresh()
        # È¢ÑËßàÊï∞ÈáèËã•ÂèëÁîüÂèòÂåñÔºàÊú™Êù•Âä† 3D ËßÜÂõæÔºâÔºåË¶ÅÊõ¥Êñ∞Âè≥‰æßÊªëÊù°ËåÉÂõ¥
        self._update_viewport_slider_range()



class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Artery GUI ‚Äî QtCompat Skeleton")
        self.resize(1480, 920)

        # Core data model
        self.volume = VolumeData()

        # Left toolbar
        self.left = LeftToolbar()
        self.left.openRequested.connect(self._open_file)
        
        self.left.spnLevel.valueChanged.connect(
            lambda v: self.volume.set_window(v, self.left.spnWidth.value())
        )
        self.left.spnWidth.valueChanged.connect(
            lambda v: self.volume.set_window(self.left.spnLevel.value(), v)
        )


        self.left.openMaskRequested.connect(self._open_mask)

        # Mask ÈÄèÊòéÂ∫¶
        self.left.sldMaskAlpha.valueChanged.connect(
            lambda v: self.volume.set_mask_alpha(v / 100.0)
        )

        # ÊòæÁ§∫Ê®°Âºè

        def _on_mode_changed(id_):
            mode = {
                0: "overlay",
                1: "image_only",
                2: "mask_only",
                3: "image_masked",
            }.get(id_, "overlay")
            self.volume.set_display_mode(mode)


        self.left.grpMode.idClicked.connect(_on_mode_changed)

        # Middle previews
        self.middle = MiddleColumn(self.volume)
        self.middle.zoomRequested.connect(self._promote_preview)

        # Right detail view
        # self.right = DetailView(self.volume)

        # Âè≥‰æßÔºö2D + 3D Â†ÜÂè†
        self.right2d = DetailView(self.volume)
        self.right3d = DetailView3D()
        self.rightStack = QtWidgets.QStackedWidget()
        self.rightStack.addWidget(self.right2d)   # index 0
        self.rightStack.addWidget(self.right3d)   # index 1
        self.rightStack.setCurrentIndex(0)




        # Arrange columns using a central widget with a grid
        central = QtWidgets.QWidget()
        grid = QtWidgets.QGridLayout(central)
        grid.setContentsMargins(6, 6, 6, 6)
        grid.setHorizontalSpacing(8)
        grid.setVerticalSpacing(8)

        grid.addWidget(self.left, 0, 0)
        grid.addWidget(self.middle, 0, 1, 1, 1)
        # grid.addWidget(self.right, 0, 2, 1, 1)
        # ÊëÜÊîæÊó∂Áî® rightStack
        grid.addWidget(self.rightStack, 0, 2, 1, 1)
        grid.setColumnStretch(0, 0)
        grid.setColumnStretch(1, 1)
        grid.setColumnStretch(2, 2)

        self.setCentralWidget(central)

        # Status bar
        self.status = self.statusBar()
        self._update_status("Ready")

    # ---------- Slots ----------
    def _update_status(self, text: str):
        self.status.showMessage(text)

    def _open_file(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Open Image file", os.getcwd(), "NIfTI (*.nii *.nii.gz)"
        )
        if not path:
            return
        try:
            self.volume.load_nii(path)
            z, y, x = self.volume.shape_zyx()
            self._update_status(f"Loaded: {os.path.basename(path)} ‚Äî shape (Z,Y,X)=({z},{y},{x})")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Load Error", str(e))
            self._update_status("Load failed")

    def _open_mask(self):
        path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Open Mask NIfTI", os.getcwd(), "NIfTI (*.nii *.nii.gz)"
        )
        if not path:
            return
        try:
            self.volume.load_mask(path)
            self._update_status(f"Loaded mask: {os.path.basename(path)}")
        except Exception as e:
            QtWidgets.QMessageBox.critical(self, "Load Mask Error", str(e))
            self._update_status("Load mask failed")


    # def _promote_preview(self, preview):


    #     if hasattr(preview, "view") and isinstance(preview.view, gl.GLViewWidget):
    #         QtWidgets.QMessageBox.information(self, "3D Promote",
    #             "ÂΩìÂâçÂè≥‰æßÂ§ßÂõæ‰∏∫2DËßÜÂõæ„ÄÇ\n‰∏ã‰∏ÄÊ≠•ÊàëÂèØ‰ª•‰∏∫‰Ω†Âä†‰∏Ä‰∏™Âè≥‰æß3DÂ§ßÂõæÊ®°ÂºèÔºàÂèØÁº©ÊîæÊóãËΩ¨Ôºâ„ÄÇ")
    #         return
    #     self.right.promote_from(preview.plane, preview.img_item, preview.view)

    #     self._update_status(f"Detail view: {preview.plane}")
    def _promote_preview(self, preview):
        # 3D È¢ÑËßàÔºöÊîæÂ§ßÂà∞Âè≥‰æß 3D
        if isinstance(preview, Volume3DPreview):
            rgba = preview.export_rgba()
            if rgba is None:
                QtWidgets.QMessageBox.information(self, "3D",
                    "3D Â∞öÊú™ÁîüÊàêÔºåËØ∑ÂÖàÂú®‰ªª‰∏Ä 2D È¢ÑËßà‰∏≠ÁÇπÂáª Update„ÄÇ")
                return
            self.right3d.show_rgba(rgba)
            self.rightStack.setCurrentIndex(1)  # ÂàáÂà∞ 3D
            self._update_status("Detail view: 3D")
            return

        # 2DÔºöËµ∞ÂéüÊúâ promote
        self.right2d.promote_from(preview.plane, preview.img_item, preview.view)
        self.rightStack.setCurrentIndex(0)
        self._update_status(f"Detail view: {preview.plane}")

# ------------------------ Entry ------------------------
if __name__ == "__main__":
    # Better performance on high-DPI displays
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)
    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)

    app = QtWidgets.QApplication(sys.argv)
    pg.setConfigOptions(imageAxisOrder='row-major')  # ensures ImageItem uses (row, col)

    win = MainWindow()
    win.show()
    sys.exit(app.exec_())
